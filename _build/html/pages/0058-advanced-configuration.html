<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Advanced Configuration Topics &mdash; Fuel for OpenStack 3.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Fuel for OpenStack 3.0 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../index.html">Fuel for OpenStack 3.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Advanced Configuration Topics</a><ul>
<li><a class="reference internal" href="#adding-and-configuring-custom-services">Adding And Configuring Custom Services</a><ul>
<li><a class="reference internal" href="#fuel-usage-scenarios-and-how-they-affect-installation">Fuel usage scenarios and how they affect installation</a></li>
<li><a class="reference internal" href="#installing-the-new-service-along-with-fuel">Installing the new service along with Fuel</a></li>
<li><a class="reference internal" href="#defining-a-new-component">Defining a new component</a></li>
<li><a class="reference internal" href="#fuel-api-reference">Fuel API Reference</a></li>
</ul>
</li>
<li><a class="reference internal" href="#openstack-networking-ha">OpenStack Networking HA</a></li>
<li><a class="reference internal" href="#l23network">L23network</a><ul>
<li><a class="reference internal" href="#usage">Usage</a></li>
<li><a class="reference internal" href="#l2-network-configuation-open-vswitch-only">L2 network configuation (Open vSwitch only)</a></li>
<li><a class="reference internal" href="#l3-network-configuration">L3 network configuration</a></li>
<li><a class="reference internal" href="#bonding">Bonding</a></li>
<li><a class="reference internal" href="#q-vlan-access-ports">802.1q vlan access ports</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/pages/0058-advanced-configuration.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="advanced-configuration-topics">
<span id="production"></span><h1>Advanced Configuration Topics<a class="headerlink" href="#advanced-configuration-topics" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#adding-and-configuring-custom-services" id="id1">Adding And Configuring Custom Services</a><ul>
<li><a class="reference internal" href="#fuel-usage-scenarios-and-how-they-affect-installation" id="id2">Fuel usage scenarios and how they affect installation</a></li>
<li><a class="reference internal" href="#installing-the-new-service-along-with-fuel" id="id3">Installing the new service along with Fuel</a></li>
<li><a class="reference internal" href="#defining-a-new-component" id="id4">Defining a new component</a></li>
<li><a class="reference internal" href="#fuel-api-reference" id="id5">Fuel API Reference</a></li>
</ul>
</li>
<li><a class="reference internal" href="#openstack-networking-ha" id="id6">OpenStack Networking HA</a></li>
<li><a class="reference internal" href="#l23network" id="id7">L23network</a><ul>
<li><a class="reference internal" href="#usage" id="id8">Usage</a></li>
<li><a class="reference internal" href="#l2-network-configuation-open-vswitch-only" id="id9">L2 network configuation (Open vSwitch only)</a></li>
<li><a class="reference internal" href="#l3-network-configuration" id="id10">L3 network configuration</a></li>
<li><a class="reference internal" href="#bonding" id="id11">Bonding</a></li>
<li><a class="reference internal" href="#q-vlan-access-ports" id="id12">802.1q vlan access ports</a></li>
</ul>
</li>
</ul>
</div>
<p>This section covers subjects that go beyond the standard OpenStack cluster, from configuring OpenStack Networking for high-availability to adding your own custom components to your cluster using Fuel.</p>
<div class="section" id="adding-and-configuring-custom-services">
<h2><a class="toc-backref" href="#id1">Adding And Configuring Custom Services</a><a class="headerlink" href="#adding-and-configuring-custom-services" title="Permalink to this headline">¶</a></h2>
<p>Fuel is designed to help you easily install a standard OpenStack cluster, but what do you do if your cluster is not standard? What if you need services or components that are not included with the standard Fuel distribution? This document gives you all of the information you need to add custom services and packages to a Fuel-deployed cluster.</p>
<div class="section" id="fuel-usage-scenarios-and-how-they-affect-installation">
<h3><a class="toc-backref" href="#id2">Fuel usage scenarios and how they affect installation</a><a class="headerlink" href="#fuel-usage-scenarios-and-how-they-affect-installation" title="Permalink to this headline">¶</a></h3>
<p>Two basic Fuel usage scenarios exist:</p>
<div class="highlight-python"><pre>* In the first scenario, a deployment engineer uses the Fuel ISO image to create a master node, make necessary changes to configuration files, and deploy OpenStack.  In this scenario, each node gets a clean OpenStack installation.

* In the second scenario, the master node and other nodes in the cluster have already been installed, and the deployment engineer has to deploy OpenStack to an existing configuration.</pre>
</div>
<p>For this discussion, the first scenario requires that any customizations needed must be applied during the deployment and the second scenario already has customizations applied.</p>
<p>In most cases, best practices dictate that you deploy and test OpenStack first, later adding any custom services. Fuel works using puppet manifests, so the simplest way to install a new service is to edit the current site.pp file on the Puppet Master to add any additional deployment paths for the target nodes. There are, however, certain components that must be installed prior to the installation of OpenStack (i.e., hardware drivers, management software, etc...). In cases like these, Puppet can only be used to perform these installations using a separate, custom site.pp file that prepares the target system(s) for OpenStack installation. An advantage to this method, however, is that it helps isolate version mismatches and the various OpenStack dependencies.</p>
<p>If a pre-deployment site.pp approach is not an option, you can inject a custom component installation into the existing Fuel manifests. If you elect to go this route, you&#8217;ll need to be aware of software source compatibility issues, as well as installation stages, component versions, incompatible dependencies, and declared resource names.</p>
<p>In short, simple custom component installation may be accomplished by editing the site.pp file, but more complex components should be added as new Fuel components.</p>
<p>In the next section we take a closer look at what you need to know.</p>
</div>
<div class="section" id="installing-the-new-service-along-with-fuel">
<h3><a class="toc-backref" href="#id3">Installing the new service along with Fuel</a><a class="headerlink" href="#installing-the-new-service-along-with-fuel" title="Permalink to this headline">¶</a></h3>
<p>When it comes to installing your new service or component alongside Fuel, you have several options. How you go about it depends on where in the process the component needs to be available. Let&#8217;s look at each step and how it can impact your installation.</p>
<p><strong>Boot the master node</strong></p>
<p>In most cases, you will be installing the master node from the Fuel ISO. This is a semi-automated step, and doesn&#8217;t allow for any custom components. If for some reason you need to install a node at this level, you will need to use the manual Fuel installation procedure.</p>
<p><strong>Cobbler configuration</strong></p>
<p>If your customizations need to take place before the install of the operating system, or even as part of the operating system install, this is where you will add them to the configuration process. This is also where you would make customizations to other services. At this stage, you are making changes to the operating system kickstart/pre-seed files, and may include any custom software source and components required to install the operating system for a node. Anything that needs to be installed before OpenStack should be configured during this step.</p>
<p><strong>OpenStack installation</strong></p>
<p>It is during this stage that you perform any Puppet, Astute, or mCollective configuration. In most cases, this means customizing the Puppet site.pp file to add any custom components during the actual OpenStack installation.</p>
<p>This step actually includes several different stages. (In fact, Puppet STDLib defines several additional default stages that fuel does not use.) These stages include:</p>
<blockquote>
<div><ol class="arabic simple" start="0">
<li><tt class="docutils literal"><span class="pre">Puppetlabs-repo</span></tt>. mCollective uses this stage to add the Puppetlabs repositories during operating system and Puppet deployment.</li>
<li><tt class="docutils literal"><span class="pre">Openstack-custom-repo</span></tt>. Additional repositories required by OpenStack are configured at this stage. Additionally, to avoid compatibility issues, the Puppetlabs repositories are switched off at this stage. As a general rule, it is a good idea to turn off any unnecessary software repositories defined for operating system installation.</li>
<li><tt class="docutils literal"><span class="pre">FUEL</span></tt>. During this stage, Fuel performs any actions defined for the current operating system.</li>
<li><tt class="docutils literal"><span class="pre">Netconfig</span></tt>. During this stage, Fuel performs all network configuration actions. This means that you should include any custom components that are related to the network in this stage.</li>
<li><tt class="docutils literal"><span class="pre">Main</span></tt>. The actual OpenStack installation process happens during this stage. Install any remaining non-network-related components during or after this stage.</li>
</ol>
</div></blockquote>
<p><strong>Post-OpenStack install</strong></p>
<p>At this point, OpenStack is installed. You may add any components you like at this point. We suggest that you take care at this point so as not to break OpenStack. This is a good place to make an image of the nodes to have a roll-back in case of any catestrophic errors that render OpenStack or any other components inoperable. If you are preparing to deploy a large-scale environment, you may want to perform a small-scale test to familiarize yourself with the entire process and make yourself aware of any potential gotchas that are specific to your infrastructure. You should perform this small-scale test using the same hardware that the large-scale deployment will use and not VirtualBox. VirtualBox does not offer the ability to test any custom hardware driver installations your physical hardware may require.</p>
</div>
<div class="section" id="defining-a-new-component">
<h3><a class="toc-backref" href="#id4">Defining a new component</a><a class="headerlink" href="#defining-a-new-component" title="Permalink to this headline">¶</a></h3>
<p>In general, we recommend you follow these steps to define a new component:</p>
<ol class="arabic">
<li><p class="first"><strong>Custom stages. Optional.</strong></p>
<p>Declare a custom stage or stages to help Puppet understand the required installation sequence. Stages are special markers indicating the sequence of actions. Best practice is to use the input parameter Before for every stage, to help define the correct sequence. The default built-in stage is &#8220;main&#8221;. Every Puppet action is automatically assigned to the main stage if no stage is explicitly specified for the action.</p>
<p>Note that since Fuel installs almost all of OpenStack during the main stage, custom stages may not help, so future plans include breaking the OpenStack installation into several sub-stages.</p>
<p>Don&#8217;t forget to take into account other existing stages; training several parallel sequences of stages increases the chances that Puppet will order them in correctly if you do not explicitly specify the order.</p>
<p><em>Example</em>:</p>
<div class="highlight-python"><pre>stage {'Custom stage 1':
   before  =&gt; Stage['Custom stage 2'],
}
stage {'Custom stage 2':
   before  =&gt; Stage['main'],
}</pre>
</div>
<p>Note that there are several limitations to stages, and they should be used with caution and only with the simplest of classes. You can find more information regarding stages and limitations here:  <a class="reference external" href="http://docs.puppetlabs.com/puppet/2.7/reference/lang_run_stages.html">http://docs.puppetlabs.com/puppet/2.7/reference/lang_run_stages.html</a>.</p>
</li>
<li><p class="first"><strong>Custom repositories. Optional.</strong></p>
<p>If the custom component requires a custom software source, you may declare a new repository and add it during one of the early stages of the installation.</p>
</li>
<li><p class="first"><strong>Common variable definition</strong></p>
<p>It is a good idea to have all common variables defined in a single place. Unlike variables in many other languages, Puppet  variables are actually constants, and may be assigned only once inside a given scope.</p>
</li>
<li><p class="first"><strong>OS and condition-dependent variable definition</strong></p>
<p>We suggest that you assign all common operating system or condition-dependent variables to a single location, preferably near the other common variables. Also, be sure to always use a <tt class="docutils literal"><span class="pre">default</span></tt> section when defining conditional operators or you could experience configuration issues.</p>
</li>
</ol>
<p><em>Example</em>:</p>
<div class="highlight-python"><pre>case $::osfamily {
   # RedHat in most cases should work for CentOS and Fedora as well
   'RedHat': {
      # List of packages to get from URL/path.
      # Separate list should be defined for each separate URL!
      $custom_package_list_from_url = ['qpid-cpp-server-0.14-16.el6.x86_64.rpm']
   }
   'Debian': {
      # List of packages to get from URL/path.
      # Separate list should be defined for each separate URL!
      $custom_package_list_from_url = [ "qpidd_0.14-2_amd64.deb" ]
   }
   default: {
      fail("Module install_custom_package does not support ${::operatingsystem}")
   }
}</pre>
</div>
<ol class="arabic">
<li><p class="first"><strong>Define installation procedures for independent custom components as classes</strong></p>
<p>You can think of public classes as singleton collections, or as a named block of code with its own namespace. Each class should be defined only once, but every class may be used with different input variable sets. The best practice is to define a separate class for every component, define required sub-classes for sub-components, and include class-dependent required resources within the actual class/subclass.</p>
</li>
</ol>
<p><em>Example</em>:</p>
<div class="highlight-python"><pre>class add_custom_service (
   # Input parameter definitions:
      # Name of the service to place behind HAProxy. **Mandatory**.
      # This name appears as a new HAProxy configuration block in /etc/haproxy/haproxy.cfg.
      $service_name_in_haproxy_config,
      $custom_package_download_url,
      $custom_package_list_from_url,
      #The list of remaining input parameters
      ...
) {
# HAProxy::params is a container class holding default parameters for the haproxy class. It adds and populates the Global and Default sections in /etc/haproxy/haproxy.cfg.
# If you install a custom service over the already deployed HAProxy configuration, it is probably better to comment out the following string:
include haproxy::params
#Class resources definitions:
    # Define the list of package names to be installed
    define install_custom_package_from_url (
       $custom_package_download_url,
       $package_provider = undef
    ) {
       exec { "download-${name}" :
              command     =&gt; "/usr/bin/wget -P/tmp ${custom_package_download_url}/${name}",
              creates     =&gt; "/tmp/${name}",
       } -&gt;
       install_custom_package { "${name}" :
              provider    =&gt; $package_provider,
              source      =&gt; "/tmp/${name}",
       }
      }
   define install_custom_package (
      $package_provider = undef,
      $package_source = undef
   ) {
      package { "custom-${name}" :
                ensure      =&gt; present,
                provider    =&gt; $package_provider,
                source      =&gt; $package_source
      }
     }

   #Here we actually install all the packages from a single URL.
   if is_array($custom_package_list_from_url) {
       install_custom_package_from_url { $custom_package_list_from_url :
           provider    =&gt; $package_provider,
           custom_package_download_url =&gt; $custom_package_download_url,
       }
   }
 }</pre>
</div>
<ol class="arabic">
<li><p class="first"><strong>Target nodes</strong></p>
<p>Every component should be explicitly assigned to a particular target node or nodes. To do that, declare the node or nodes within site.pp. When Puppet runs the manifest for each node, it compares each node definition with the name of the current hostname and applies only to classes assigned to the current node.  Node definitions may include regular expressions. For example, you can apply the class &#8216;add custom service&#8217; to all controller nodes with hostnames fuel-controller-00 to fuel-controller-xxx, where xxx = any integer value using the following definition:</p>
</li>
</ol>
<p><em>Example</em>:</p>
<div class="highlight-python"><pre>node /fuel-controller-[\d+]/ {
  include stdlib
  class { 'add_custom_service':
    stage =&gt; 'Custom stage 1',
    service_name_in_haproxy_config =&gt; $service_name_in_haproxy_config,
    custom_package_download_url =&gt; $custom_package_download_url,
    custom_package_list_from_url =&gt; $custom_package_list_from_url,
  }
}</pre>
</div>
</div>
<div class="section" id="fuel-api-reference">
<h3><a class="toc-backref" href="#id5">Fuel API Reference</a><a class="headerlink" href="#fuel-api-reference" title="Permalink to this headline">¶</a></h3>
<p><strong>add_haproxy_service</strong>
Location: Top level</p>
<p>As the name suggests, this function enables you to create a new HAProxy service.  The service is defined in the <tt class="docutils literal"><span class="pre">/etc/haproxy/haproxy.cfg</span></tt> file, and generally looks something like this:</p>
<div class="highlight-python"><pre>listen keystone-2
  bind 10.0.74.253:35357
  bind 10.0.0.110:35357
  balance  roundrobin
  option  httplog
  server  fuel-controller-01.example.com 10.0.0.101:35357   check
  server  fuel-controller-02.example.com 10.0.0.102:35357   check</pre>
</div>
<p>To accomplish this, you might create a Fuel statement such as:</p>
<div class="highlight-python"><pre>add_haproxy_service { 'keystone-2' :
    order =&gt; 30,
    balancers =&gt; {'fuel-controller-01.example.com' =&gt; '10.0.0.101',
                  'fuel-controller-02.example.com' =&gt; '10.0.0.102'},
    virtual_ips =&gt; {'10.0.74.253', '10.0.0.110'},
    port =&gt; '35357',
    haproxy_config_options =&gt; { 'option' =&gt; ['httplog'], 'balance' =&gt; 'roundrobin' },
    balancer_port =&gt; '35357',
    balancermember_options =&gt; 'check',
    mode =&gt; 'tcp',
    define_cookies =&gt; false,
    define_backend =&gt; false,
    collect_exported =&gt; false
    }</pre>
</div>
<p>Let&#8217;s look at how this command works.</p>
<p><strong>Usage:</strong></p>
<div class="highlight-python"><pre>add_haproxy_service { '&lt;SERVICE_NAME&gt;' :
    order =&gt; $order,
    balancers =&gt; $balancers,
    virtual_ips =&gt; $virtual_ips,
    port =&gt; $port,
    haproxy_config_options =&gt; $haproxy_config_options,
    balancer_port =&gt; $balancer_port,
    balancermember_options =&gt; $balancermember_options,
    mode =&gt; $mode, #Optional. Default is 'tcp'.
    define_cookies =&gt; $define_cookies, #Optional. Default false.
    define_backend =&gt; $define_backend,#Optional. Default false.
    collect_exported =&gt; $collect_exported, #Optional. Default false.
    }</pre>
</div>
<p><strong>Parameters:</strong></p>
<p><tt class="docutils literal"><span class="pre">&lt;'Service</span> <span class="pre">name'&gt;</span></tt></p>
<p>The name of the new HAProxy listener section. In our example it was <tt class="docutils literal"><span class="pre">keystone-2</span></tt>. If you want to include an IP address or port in the listener name, you have the option to use a name such as:</p>
<div class="highlight-python"><pre>'stats 0.0.0.0:9000       #Listen on all IP's on port 9000'</pre>
</div>
<p><tt class="docutils literal"><span class="pre">order</span></tt></p>
<p>This parameter determines the order of the file fragments. It is optional, but we strongly recommend setting it manually. Fuel already has several different order values from 1 to 100 hardcoded for HAProxy configuration. If your HAProxy configuration fragments appear in the wrong places in <tt class="docutils literal"><span class="pre">/etc/haproxy/haproxy.cfg</span></tt> this is likely due to an incorrect order value. It is acceptable to set order values greater than 100 in order to place your custom configuration block at the end of <tt class="docutils literal"><span class="pre">haproxy.cfg</span></tt>.</p>
<p>Puppet assembles configuration files from fragments. First it creates several configuration fragments and temporarily stores all of them as separate files. Every fragment has a name such as <tt class="docutils literal"><span class="pre">${order}-${fragment_name}</span></tt>, so the order determines the number of the current fragment in the fragment sequence. After all the fragments are created, Puppet reads the fragment names and sorts them in ascending order, concatenating all the fragments in that order. In other words, a fragment with a smaller order value always goes before all fragments with a greater order value.</p>
<p>The <tt class="docutils literal"><span class="pre">keystone-2</span></tt> fragment from the example above has <tt class="docutils literal"><span class="pre">order</span> <span class="pre">=</span> <span class="pre">30</span></tt> so it&#8217;s placed after the <tt class="docutils literal"><span class="pre">keystone-1</span></tt> section (<tt class="docutils literal"><span class="pre">order</span> <span class="pre">=</span> <span class="pre">20</span></tt>) and the <tt class="docutils literal"><span class="pre">nova-api-1</span></tt> section (order = 40).</p>
<p><tt class="docutils literal"><span class="pre">balancers</span></tt></p>
<p>Balancers (or <strong>Backends</strong> in HAProxy terms) are a hash of <tt class="docutils literal"><span class="pre">{</span> <span class="pre">&quot;$::hostname&quot;</span> <span class="pre">=&gt;</span> <span class="pre">$::ipaddress</span> <span class="pre">}</span></tt> values.
The default is <tt class="docutils literal"><span class="pre">{</span> <span class="pre">&quot;&lt;current</span> <span class="pre">hostname&gt;&quot;</span> <span class="pre">=&gt;</span> <span class="pre">&lt;current</span> <span class="pre">ipaddress&gt;</span> <span class="pre">}</span></tt>, but that value is set for compatability only, and may not work correctly in HA mode.  Instead, the default for HA mode is to explicitly set the Balancers as</p>
<div class="highlight-python"><pre>  Haproxy_service {
    balancers =&gt; $controller_internal_addresses
}</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">$controller_internal_addresses</span></tt> represents a hash of all the controllers with a corresponding internal IP address; this value is set in <tt class="docutils literal"><span class="pre">site.pp</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">balancers</span></tt> parameter is a list of HAProxy listener balance members (hostnames) with corresponding IP addresses. The following strings from the <tt class="docutils literal"><span class="pre">keystone-2</span></tt> listener example represent balancers:</p>
<div class="highlight-python"><pre>server  fuel-controller-01.example.com 10.0.0.101:35357   check
server  fuel-controller-02.example.com 10.0.0.102:35357   check</pre>
</div>
<p>Every key pair in the <tt class="docutils literal"><span class="pre">balancers</span></tt> hash adds a new string to the list of balancers defined in the listener section. Different options may be set for every string.</p>
<p><tt class="docutils literal"><span class="pre">virtual_ips</span></tt></p>
<p>This parameter represents an array of IP addresses (or <strong>Frontends</strong> in HAProxy terms) of the current listener. Every IP address in this array adds a new string to the bind section of the current listeners. The following strings from the <tt class="docutils literal"><span class="pre">keystone-2</span></tt> listener example represent virtual IPs:</p>
<div class="highlight-python"><pre>bind 10.0.74.253:35357
bind 10.0.0.110:35357</pre>
</div>
<p><tt class="docutils literal"><span class="pre">port</span></tt></p>
<p>This parameters specifies the frontend port for the listeners. Currently you must set the same port frontends.
The following strings from the <tt class="docutils literal"><span class="pre">keystone-2</span></tt> listener example represent the frontend port, where the port is 35357:</p>
<div class="highlight-python"><pre>bind 10.0.74.253:35357
bind 10.0.0.110:35357</pre>
</div>
<p><tt class="docutils literal"><span class="pre">haproxy_config_options</span></tt></p>
<p>This parameter represents a hash of key pairs of HAProxy listener options in the form <tt class="docutils literal"><span class="pre">{</span> <span class="pre">'option</span> <span class="pre">name'</span> <span class="pre">=&gt;</span> <span class="pre">'option</span> <span class="pre">value'</span> <span class="pre">}</span></tt>.   Every key pair from this hash adds a new string to the listener options.</p>
<p><strong>NOTE</strong> Every HAProxy option may require a different input value type, such as strings or a list of multiple options per single string.</p>
<p>The &#8216;<cite>keystone-2`</cite> listener example has the <tt class="docutils literal"><span class="pre">{</span> <span class="pre">'option'</span> <span class="pre">=&gt;</span> <span class="pre">['httplog'],</span> <span class="pre">'balance'</span> <span class="pre">=&gt;</span> <span class="pre">'roundrobin'</span> <span class="pre">}</span></tt> option array and this array is represented as the following in the resulting /etc/haproxy/haproxy.cfg:</p>
<blockquote>
<div>balance  roundrobin
option  httplog</div></blockquote>
<p><tt class="docutils literal"><span class="pre">balancer_port</span></tt></p>
<p>This parameter represents the balancer (backend) port. By default, the balancer_port is the same as the frontend <tt class="docutils literal"><span class="pre">port</span></tt>. The following strings from the <tt class="docutils literal"><span class="pre">keystone-2</span></tt> listener example represent <tt class="docutils literal"><span class="pre">balancer_port</span></tt>, where port is <tt class="docutils literal"><span class="pre">35357</span></tt>:</p>
<div class="highlight-python"><pre>server  fuel-controller-01.example.com 10.0.0.101:35357   check
server  fuel-controller-02.example.com 10.0.0.102:35357   check</pre>
</div>
<p><tt class="docutils literal"><span class="pre">balancermember_options</span></tt></p>
<p>This is a string of options added to each balancer (backend) member. The <tt class="docutils literal"><span class="pre">keystone-2</span></tt> listener example has the single <tt class="docutils literal"><span class="pre">check</span></tt> option:</p>
<div class="highlight-python"><pre>server  fuel-controller-01.example.com 10.0.0.101:35357   check
server  fuel-controller-02.example.com 10.0.0.102:35357   check</pre>
</div>
<p><tt class="docutils literal"><span class="pre">mode</span></tt></p>
<p>This optional parameter represents the HAProxy listener mode. The default value is <tt class="docutils literal"><span class="pre">tcp</span></tt>, but Fuel writes <tt class="docutils literal"><span class="pre">mode</span> <span class="pre">http</span></tt> to the defaults section of <tt class="docutils literal"><span class="pre">/etc/haproxy/haproxy.cfg</span></tt>. You can set the same option via  <tt class="docutils literal"><span class="pre">haproxy_config_options</span></tt>. A separate mode parameter is required to set some modes by default on every new listener addition. The <tt class="docutils literal"><span class="pre">keystone-2</span></tt> listener example has no <tt class="docutils literal"><span class="pre">mode</span></tt> option and so it works in the default Fuel-configured HTTP mode.</p>
<p><tt class="docutils literal"><span class="pre">define_cookies</span></tt></p>
<p>This optional boolean parameter is a Fuel-only feature.  The default is <tt class="docutils literal"><span class="pre">false</span></tt>, but if set to <tt class="docutils literal"><span class="pre">true</span></tt>, Fuel directly adds <tt class="docutils literal"><span class="pre">cookie</span> <span class="pre">${hostname}</span></tt> to every balance member (backend).</p>
<p>The <tt class="docutils literal"><span class="pre">keystone-2</span></tt> listener example has no <tt class="docutils literal"><span class="pre">define_cookies</span></tt> option. Typically, frontend cookies are added with <tt class="docutils literal"><span class="pre">haproxy_config_options</span></tt> and backend cookies with <tt class="docutils literal"><span class="pre">balancermember_options</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">collect_exported</span></tt></p>
<p>This optional boolean parameter has a default value of <tt class="docutils literal"><span class="pre">false</span></tt>.  True means &#8216;collect exported &#64;&#64;balancermember resources&#8217; (when every balancermember node exports itself), while false means &#8216;rely on the existing declared balancermember resources&#8217; (for when you know the full set of balancermembers in advance and use <tt class="docutils literal"><span class="pre">haproxy::balancermember</span></tt> with array arguments, which allows you to deploy everything in one run).</p>
</div>
</div>
<div class="section" id="openstack-networking-ha">
<h2><a class="toc-backref" href="#id6">OpenStack Networking HA</a><a class="headerlink" href="#openstack-networking-ha" title="Permalink to this headline">¶</a></h2>
<p>NOTE:  THIS DOCUMENT HAS NOT BEEN EDITED AND IS NOT READY FOR PUBLIC CONSUMPTION.</p>
<p>Fuel 2.1 introduced support for OpenStack Networking utilizing a high-availability configuration. To accomplish this, Fuel uses a combination of Pacemaker and Corosync to ensure that if the networking service goes down, it will be restarted either on the existing node or on separate node.</p>
<p>This document explains how to configure these options in your own installation.</p>
</div>
<div class="section" id="l23network">
<h2><a class="toc-backref" href="#id7">L23network</a><a class="headerlink" href="#l23network" title="Permalink to this headline">¶</a></h2>
<p>NOTE:  THIS DOCUMENT HAS NOT BEEN EDITED AND IS NOT READY FOR PUBLIC CONSUMPTION.</p>
<p>Puppet module for configuring network interfaces on 2nd and 3rd level (802.1q vlans, access ports, NIC-bonding, assign IP addresses, dhcp, and interfaces without IP addresses).</p>
<p>Can work together with Open vSwitch or standard linux way.</p>
<p>At this moment we support Centos 6.3 (RHEL6) and Ubuntu 12.04 or above.</p>
<div class="section" id="usage">
<h3><a class="toc-backref" href="#id8">Usage</a><a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h3>
<p>Place this module at /etc/puppet/modules or on another path that contains your puppet modules.</p>
<p>Include L23network module and initialize it. I recommend to do it in an early stage:</p>
<div class="highlight-python"><pre>#Network configuration
stage {'netconfig':
  before  =&gt; Stage['main'],
}
class {'l23network': stage=&gt; 'netconfig'}</pre>
</div>
<p>If you do not plan to use Open vSwitch &#8211; you can disable it:</p>
<div class="highlight-python"><pre>class {'l23network': use_ovs=&gt;false, stage=&gt; 'netconfig'}</pre>
</div>
</div>
<div class="section" id="l2-network-configuation-open-vswitch-only">
<h3><a class="toc-backref" href="#id9">L2 network configuation (Open vSwitch only)</a><a class="headerlink" href="#l2-network-configuation-open-vswitch-only" title="Permalink to this headline">¶</a></h3>
<p>Current layout is:
* <em>bridges</em> &#8211; A &#8220;Bridge&#8221; is a virtual ethernet L2 switch. You can plug ports into it.
* <em>ports</em> &#8211; A Port is an interface you plug into the bridge (switch). It&#8217;s a virtual.  (virtual what?)
* <em>interface</em> &#8211; A physical implementation of port.</p>
<p>Then in your manifest you can either use the things as parameterized classes:</p>
<div class="highlight-python"><pre>class {"l23network": }

l23network::l2::bridge{"br-mgmt": }
l23network::l2::port{"eth0": bridge =&gt; "br-mgmt"}
l23network::l2::port{"mmm0": bridge =&gt; "br-mgmt"}
l23network::l2::port{"mmm1": bridge =&gt; "br-mgmt"}

l23network::l2::bridge{"br-ex": }
l23network::l2::port{"eth0": bridge =&gt; "br-ex"}
l23network::l2::port{"eth1": bridge =&gt; "br-ex", ifname_order_prefix='ovs'}
l23network::l2::port{"eee0": bridge =&gt; "br-ex", skip_existing =&gt; true}
l23network::l2::port{"eee1": bridge =&gt; "br-ex", type=&gt;'internal'}</pre>
</div>
<p>You can define type for the port. Port type can be
&#8216;system&#8217;, &#8216;internal&#8217;, &#8216;tap&#8217;, &#8216;gre&#8217;, &#8216;ipsec_gre&#8217;, &#8216;capwap&#8217;, &#8216;patch&#8217;, &#8216;null&#8217;.
If you do not define type for port (or define &#8216;&#8217;) &#8211; ovs-vsctl will have default behavior
(see <a class="reference external" href="http://openvswitch.org/cgi-bin/ovsman.cgi?page=utilities%2Fovs-vsctl.8">http://openvswitch.org/cgi-bin/ovsman.cgi?page=utilities%2Fovs-vsctl.8</a>).</p>
<p>You can use <em>skip_existing</em> option if you do not want to interrupt configuration while adding an existing port or bridge.</p>
</div>
<div class="section" id="l3-network-configuration">
<h3><a class="toc-backref" href="#id10">L3 network configuration</a><a class="headerlink" href="#l3-network-configuration" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><div class="highlight-python"><pre>### Simple IP address definition, DHCP or address-less interfaces
l23network::l3::ifconfig {"eth0": ipaddr=&gt;'192.168.1.1/24'}
l23network::l3::ifconfig {"xXxXxXx":
    interface =&gt; 'eth1',
    ipaddr    =&gt; '192.168.2.1',
    netmask   =&gt; '255.255.255.0'
}
l23network::l3::ifconfig {"eth2": ipaddr=&gt;'dhcp'}
l23network::l3::ifconfig {"eth3": ipaddr=&gt;'none'}</pre>
</div>
</div></blockquote>
<p>Option <em>ipaddr</em> can contains IP address, &#8216;dhcp&#8217;, or &#8216;none&#8217; string. In this example we describe configuration of 4 network interfaces:
* Interface <em>eth0</em> have short CIDR-notated form of IP address definition.
* Interface <em>eth1</em>
* Interface <em>eth2</em> will be configured to use dhcp protocol.
* Interface <em>eth3</em> will be configured as interface without IP address. Often you will need to create &#8220;master&#8221; interface for 802.1q vlans (in native linux implementation) or as slave interface for bonding.</p>
<p>CIDR-notated form of IP address has more priority, that classic <em>ipaddr</em> and <em>netmask</em> definition.
If you omitted <em>natmask</em> and did not use CIDR-notated form &#8211; default <em>netmask</em> value will be used as &#8216;255.255.255.0&#8217;.:</p>
<div class="highlight-python"><pre>### Multiple IP addresses for one interface (aliases)

l23network::l3::ifconfig {"eth0":
  ipaddr =&gt; ['192.168.0.1/24', '192.168.1.1/24', '192.168.2.1/24']
}</pre>
</div>
<p>You can pass a list of CIDR-notated IP addresses to the <em>ipaddr</em> parameter to assign many IP addresses to one interface.  This will create aliases (not subinterfaces). Array can contain one or more elements.</p>
<div class="highlight-python"><pre>### UP and DOWN interface order

l23network::l3::ifconfig {"eth1":
  ipaddr=&gt;'192.168.1.1/24'
}
l23network::l3::ifconfig {"br-ex":
  ipaddr=&gt;'192.168.10.1/24',
  ifname_order_prefix='ovs'
}
l23network::l3::ifconfig {"aaa0":
  ipaddr=&gt;'192.168.20.1/24',
  ifname_order_prefix='zzz'
}</pre>
</div>
<p>Centos and Ubuntu (at startup OS) start and configure network interfaces in alphabetical order
by interface configuration file names. In the example above we change configuration process order by <em>ifname_order_prefix</em> keyword. We will have this order:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ifcfg</span><span class="o">-</span><span class="n">eth1</span>
<span class="n">ifcfg</span><span class="o">-</span><span class="n">ovs</span><span class="o">-</span><span class="n">br</span><span class="o">-</span><span class="n">ex</span>
<span class="n">ifcfg</span><span class="o">-</span><span class="n">zzz</span><span class="o">-</span><span class="n">aaa0</span>
</pre></div>
</div>
<p>And OS will configure interfaces br-ex and aaa0 after eth0:</p>
<div class="highlight-python"><pre>### Default gateway

l23network::l3::ifconfig {"eth1":
    ipaddr                =&gt; '192.168.2.5/24',
    gateway               =&gt; '192.168.2.1',
    check_by_ping         =&gt; '8.8.8.8',
    check_by_ping_timeout =&gt; '30'
}</pre>
</div>
<p>In this example we define default <em>gateway</em> and options for waiting  so that the network stays up.
Parameter <em>check_by_ping</em> define IP address, that will be pinged. Puppet will be blocked for waiting response for <em>check_by_ping_timeout</em> seconds.
Parameter <em>check_by_ping</em> can be IP address, &#8216;gateway&#8217;, or &#8216;none&#8217; string for disabling checking.
By default gateway will be pinged.</p>
<div class="highlight-python"><pre>### DNS-specific options

l23network::l3::ifconfig {"eth1":
    ipaddr          =&gt; '192.168.2.5/24',
    dns_nameservers =&gt; ['8.8.8.8','8.8.4.4'],
    dns_search      =&gt; ['aaa.com','bbb.com'],
    dns_domain      =&gt; 'qqq.com'
}</pre>
</div>
<p>Also we can specify DNS nameservers, and search list that will be inserted (by resolvconf lib) to /etc/resolv.conf .
Option <em>dns_domain</em> implemented only in Ubuntu.</p>
<div class="highlight-python"><pre>### DHCP-specific options

l23network::l3::ifconfig {"eth2":
    ipaddr          =&gt; 'dhcp',
    dhcp_hostname   =&gt; 'compute312',
    dhcp_nowait     =&gt; false,
}</pre>
</div>
</div>
<div class="section" id="bonding">
<h3><a class="toc-backref" href="#id11">Bonding</a><a class="headerlink" href="#bonding" title="Permalink to this headline">¶</a></h3>
<p>### Using standard linux bond (ifenslave)
For bonding two interfaces you need to:
* Specify these interfaces as interfaces without IP addresses
* Specify that the interfaces depend on the master-bond-interface
* Assign IP address to the master-bond-interface.
* Specify bond-specific properties for master-bond-interface (if defaults are not suitable for you)</p>
<p>for example (defaults included):</p>
<div class="highlight-python"><pre>l23network::l3::ifconfig {'eth1': ipaddr=&gt;'none', bond_master=&gt;'bond0'} -&gt;
l23network::l3::ifconfig {'eth2': ipaddr=&gt;'none', bond_master=&gt;'bond0'} -&gt;
l23network::l3::ifconfig {'bond0':
    ipaddr          =&gt; '192.168.232.1',
    netmask         =&gt; '255.255.255.0',
    bond_mode       =&gt; 0,
    bond_miimon     =&gt; 100,
    bond_lacp_rate  =&gt; 1,
}</pre>
</div>
<p>More information about bonding network interfaces you can get in manuals for your operating system:
* <a class="reference external" href="https://help.ubuntu.com/community/UbuntuBonding">https://help.ubuntu.com/community/UbuntuBonding</a>
* <a class="reference external" href="http://wiki.centos.org/TipsAndTricks/BondingInterfaces">http://wiki.centos.org/TipsAndTricks/BondingInterfaces</a></p>
<p>### Using Open vSwitch
For bonding two interfaces you need:
* Specify OVS bridge
* Specify special resource &#8220;bond&#8221; and add it to bridge. Specify bond-specific parameters.
* Assign IP address to the newly-created network interface (if needed).</p>
<p>In this example we add &#8220;eth1&#8221; and &#8220;eth2&#8221; interfaces to bridge &#8220;bridge0&#8221; as bond &#8220;bond1&#8221;.</p>
<div class="highlight-python"><pre>l23network::l2::bridge{'bridge0': } -&gt;
l23network::l2::bond{'bond1':
    bridge     =&gt; 'bridge0',
    ports      =&gt; ['eth1', 'eth2'],
    properties =&gt; [
       'lacp=active',
       'other_config:lacp-time=fast'
    ],
} -&gt;
l23network::l3::ifconfig {'bond1':
    ipaddr          =&gt; '192.168.232.1',
    netmask         =&gt; '255.255.255.0',
}</pre>
</div>
<p>Open vSwitch provides lot of parameters for different configurations.
We can specify them in the &#8220;properties&#8221; option as a list of parameter=value
(or parameter:key=value) strings.
The most of them you can see in [open vSwitch documentation page](http://openvswitch.org/support/).</p>
</div>
<div class="section" id="q-vlan-access-ports">
<h3><a class="toc-backref" href="#id12">802.1q vlan access ports</a><a class="headerlink" href="#q-vlan-access-ports" title="Permalink to this headline">¶</a></h3>
<p>### Using standard linux way
We can use tagged vlans over ordinary network interfaces (or over bonds).
L23networks support two variants of naming vlan interfaces:
* <em>vlanXXX</em> &#8211; 802.1q tag gives from the vlan interface name, but you need to specify
parent interface name in the <strong>vlandev</strong> parameter.
* <em>eth0.101</em> &#8211; 802.1q tag and parent interface name gives from the vlan interface name</p>
<p>If you need to use 802.1q vlans over bonds &#8211; you can use only the first variant.</p>
<p>In this example we can see both variants:</p>
<div class="highlight-python"><pre>l23network::l3::ifconfig {'vlan6':
    ipaddr  =&gt; '192.168.6.1',
    netmask =&gt; '255.255.255.0',
    vlandev =&gt; 'bond0',
}
l23network::l3::ifconfig {'vlan5':
    ipaddr  =&gt; 'none',
    vlandev =&gt; 'bond0',
}
L23network:L3:Ifconfig['bond0'] -&gt; L23network:L3:Ifconfig['vlan6'] -&gt; L23network:L3:Ifconfig['vlan5']

l23network::l3::ifconfig {'eth0':
    ipaddr  =&gt; '192.168.0.5',
    netmask =&gt; '255.255.255.0',
    gateway =&gt; '192.168.0.1',
} -&gt;
l23network::l3::ifconfig {'eth0.101':
    ipaddr  =&gt; '192.168.101.1',
    netmask =&gt; '255.255.255.0',
} -&gt;
l23network::l3::ifconfig {'eth0.102':
    ipaddr  =&gt; 'none',
}</pre>
</div>
<p>### Using Open vSwitch
In the Open vSwitch all internal traffic is virtually tagged.
For creating the 802.1q tagged access port you need to specify vlan tag when adding a port to a bridge.
In this example we create two ports with tags 10 and 20, and assign an IP address to interface with tag 10:</p>
<div class="highlight-python"><pre>l23network::l2::bridge{'bridge0': } -&gt;
l23network::l2::port{'vl10':
    bridge  =&gt; 'bridge0',
    type    =&gt; 'internal',
    port_properties =&gt; [
        'tag=10'
    ],
} -&gt;
l23network::l2::port{'vl20':
    bridge  =&gt; 'bridge0',
    type    =&gt; 'internal',
    port_properties =&gt; [
        'tag=20'
    ],
} -&gt;
l23network::l3::ifconfig {'vl10':
    ipaddr  =&gt; '192.168.101.1/24',
} -&gt;
l23network::l3::ifconfig {'vl20':
    ipaddr  =&gt; 'none',
}</pre>
</div>
<p>Information about vlans in open vSwitch you can get in [open vSwitch documentation page](<a class="reference external" href="http://openvswitch.org/support/config-cookbooks/vlan-configuration-cookbook/">http://openvswitch.org/support/config-cookbooks/vlan-configuration-cookbook/</a>).</p>
<p><strong>IMPORTANT:</strong> You can&#8217;t use vlan interface names like vlanXXX if you do not want double-tagging of your network traffic.</p>
<p>&#8212;
When I began to write this module, I checked <a class="reference external" href="https://github.com/ekarlso/puppet-vswitch">https://github.com/ekarlso/puppet-vswitch</a>. Elcarso, big thanks...</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../index.html">Fuel for OpenStack 3.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Mirantis.
      Last updated on 2013/07/22.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>